### 对象的基本概念
* 什么是对象

> 对象就是一个可以提供特定功能的黑盒子,使用者不用关心功能的具体实现,只要知道怎么用就可以了

> 举例:电视就是一个对象,通过遥控器或者电视面板上的按钮操作电视

* 什么是面向对象的程序设计

> 开发具有特定功能的黑盒子

* 对象学什么

> * 使用对象 如:Date/Array/Math...
> * 开发自己的对象

* 对象的特点

> * 封装 把具体的功能实现包起来,对外不公开
> * 抽象 根据具体的业务需求把需要的属性和方法抽取出来
> * 继承 子类具有父类的方法和属性,然后子类再开发自己特有的方法和属性
> * 多态 把子类赋给父类,赋值后的父类具有子类的特性

* 对象的组成

> * 属性(变量)
> * 方法(函数) 

### 创建对象
* 字面量创建

> * 单体对象,适合整个系统只有一个对象的场景
> * 对象属性的特征:无序唯一
>> * 对象属性特征的应用,去除重复数组
>>> * 把数组里面的值转换为对象的属性,由于对象的属性不能重复，所以此时对象的属性就把重复的值过滤掉
>>> * 把对象的属性转换为数组的值
> * js对象和json的区别
>> * json是一种数据传输格式,js对象是类的实例,不能直接传输
>> * json的键必须添加双引号,值不能是函数,js对象键不用加双引号,值可以是任意类型,如果js对象的属性不是一个合法的变量名时需要加双引号
>> * json可以通过JSON.parse(jsonstr)转换为js对象,js对象可以用JSON.stringify(jsobj)转换为json

* 构造函数创建

> * 用系统自带的对象创建对象
>> * 缺点:会有把系统自带的方法和属性覆盖掉的风险
> * 用Object对象来创建对象
>> * Object是所有对象的父类
>> * 创建的对象方法和属性不能共用
> * 用工厂模式的函数创建对象
>> * 不能用new来创建对象
>> * 方法不能被实例共享,每个对象实例都生成一个相同的方法
> * 用new关键字创建对象 － 构造函数
>> * new 的作用,函数会在一开始创建一个对象，并且这个对象就是this,最后会把这个this对象返回出去
>> * 直接用new后可以把用工厂模式函数中创建对象和返回对象省略,但是方法还是不能被实例共享
>> * 用new后,把工厂模式函数可以看做是类,类名一般首字母大写
> * 构造函数方法共享－将构造函数里面的方法指向全局函数
>> * 缺点1.全局函数会在其他地方调用，这时会有风险
>> * 缺点2.如果方法太多，就需要创建大量的全局函数
>> * 缺点3.违背面向对象的封装特性
> * 构造原型模式
>> * 原型 prototype 是存在于构造函数上的一个对象,所有的实例对象都可以访问原型对象
>> * 可以在原型对象prototype添加共用的属性或者方法
>> * 变化的属性和方法写在构造器中 
> * 动态原型模式
>> * 可以把原型对象prototype上的定义写在构造函数中,定义之前需要唯一执行判断

### 对象中的名词解释
构造函数和类
> 用来创建对象的函数叫构造函数,也叫类

对象实例 
> 由构造函数创建的一个具体的对象

静态方法和实例方法
> 添加在构造函数上的方法是静态方法,静态方法的调用方法是 构造函数.方法名()
> 添加在构造函数的原型对象上的方法是实例方法,静态方法的调用方法是 对象的实例.方法名()

### 内存分析

<img src="img/014-001.png">

### 原型链和继承
* 原型链

> * 原型就是一个对象，所有的实例共享对象上的方法和属性
> * 一但有构造函数，系统会自动的给构造函数添加一个原型对象prototype
> * 系统会给原型对象上添加一个constructor对象(prototype.constructor)，就是构造器，整个构造器指向构造函数本身
> * 系统会给原型对象上添加另外一个__proto__的对象(prototype.__proto__)，该对象指向Object的原型对象(Object.prototype)
> * Object的原型对象(Object.prototype) 里面也有constructor对象和__proto__对象,constructor对象指向Object自己，__proto__对象指向null
> * Object的原型对象(Object.prototype) 里面除了constructor对象和__proto__对象外，还有一些系统自带的方法，比如toString(),valueOf()等等
> * 可以在原型对象上添加自己的方法和属性，这些方法和属性也会被所有的实例共享
> * 对象的实例有自己的属性和方法,同时系统会给对象实例添加__proto__对象，__proto__对象对象就是构造函数的原型对象
>* 实例对象的__proto__对象-->构造函数的原型对象，构造函数的原型对象的__proto__-->Object的原型对象，Object的原型对象的__proto__ -->null

* 原型链上的属性

> 属性的添加
>> 在实例上添加一个实例上的同名属性会覆盖原来的
>> 如果在实例对象上添加了一个构造函数原型对象上的同名属性，访问时会找到实例对象上的该属性 
> 属性的删除
>> 通过delete 删除属性
>> 删除实质是判断有没有该属性，如果有删除返回真，若没有，直接返回真
>> 如果删除了原型上的属性，所有实例都访问不到该属性 
> 属性的判断
>> 判断对象上是否有自己实例上指定的属性,如obj1.hasOwnProperty('name')
>> 判断对象的原型链上是否有指定的属性,如"LEGS" in obj1;
>> 判断属性只在原型上有
```javascript
        function hasPrototypeProperty(obj,name){
            return !obj.hasOwnProperty(name) && (name in obj);
        }
```
> 属性的定义
>> 定义单个属性
```javascript 
Object.defineProperty(对象,属性名,
{value:属性值,
enumerable:true,//是否可以枚举,默认是false
writable:true,//是否可写(赋值),默认是false
configurable:true//是否可删除,是否可以修改属性的权限，默认是false
}
);
```
>> 定义多个属性
```javascript
Object.defineProperties(对象,{
    属性名1:{value:属性值,writable:true},
    属性名2:{value:属性值,enumerable:true},
    属性名3:{value:属性值}
});
```
>> 查看属性的权限
```javascript
Object.getOwnPropertyDescriptor(对象,属性名)
```
* 继承

> 改变函数内部的this指向
>> 调用函数时,函数名.call(参数1,参数2....),call 第一个参数是被调用函数里面的this,后面是对应的参数列表
>>  调用函数时,函数名.apply(参数1,[]),apply 第一个参数是被调用函数里面的this,第二个是参数接受一个数组做为参数列表
>> 函数名.bind(参数),bind会返回一个函数,函数内部的this就是bind的参数

> 继承1
```javascript
function 子类(属性1,属性2,属性3){
    父类.call(this,属性1,属性2);//属性的继承
    this.属性3 = 属性3; //子类的属性
}

子类.prototype = 父类.prototype; //方法的继承
子类.prototype.方法 = function(){} //子类的方法
```
> 缺点:
> 由于方法的继承是引用赋值,所以父类也会有子类的方法

> 继承2
```javascript
function 子类(属性1,属性2,属性3){
    父类.call(this,属性1,属性2);//属性的继承
    this.属性3 = 属性3; //子类的属性
}

//方法的继承
for(i in 父类.prototype){
    子类.prototype[i] = 父类.prototype[i];
}
子类.prototype.方法 = function(){} //子类的方法
```
> 缺点:
> 如果父类的方法是不可枚举的,子类就继承不到

> 继承3
```javascript
function 子类(属性1,属性2,属性3){
    父类.call(this,属性1,属性2);//属性的继承
    this.属性3 = 属性3; //子类的属性
}

//方法的继承
子类.prototype = new 父类();//子类的prototype指向父类的一个实例
子类.prototype.constructor = 子类;
子类.prototype.方法 = function(){} //子类的方法
```
> 缺点:
> 调用两次父类的构造函数,同时在子类的原型上产生了不必要的父类的属性


> 继承4
```javascript
function 子类(属性1,属性2,属性3){
    父类.call(this,属性1,属性2);//属性的继承
    this.属性3 = 属性3; //子类的属性
}

//方法的继承
子类.prototype = Object.create(父类.prototype);
子类.prototype.constructor = 子类;
子类.prototype.方法 = function(){} //子类的方法
```
> Object.create(参数)
> Object.create(参数)会创建一个新对象,新创建对象的__proto__对象就是参数

### 面向对象案例:
* 选项卡
* 拖拽
* 轮播图



