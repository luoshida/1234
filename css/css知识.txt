
	文本样式

	内部引用

<p style="color:red;font-size:50px;">xxxxxxxxxx</p>
<head>
	<meta charset="utf-8">
	<title>css样式</title>
	<style type="text/css">
p{color: green; font-style: italic/*倾斜或normal*/; font-weight: 500/*字体粗细0-900取整*/; font-size: 100px/*字体大小*/; font-family: 楷体;}
h1{font: normal 900 50px 宋体;}/*这个是连写*/
	</style>
</head>
<body>
	<h1>问候语</h1>
	<p>你好，大猫</p> 
</body>

	外部引用

 在外面建一个.css的层叠样式表p{color: green;font: 100px 楷体}
两个.css的表格可以相互引用 用@import url(style2.css);引用
<head>
	<meta charset="utf-8">
	<title>css样式</title>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
	<h1>问候语</h1>
	<p>你好，大猫</p> 
</body>
样式
<style type="text/css">
	h1{
/*颜色的四种表示方法*/
		color: rgb(123,56,148);
		color: rgba(44,55,66,0.4);
		color: #FF5566;
		color: #f56;
		
		text-decoration: line-through;
/*文本修饰 underline|overline|line-through|none*/
		text-align: center;
/*文本对齐样式left(默认)|center|right*/
		text-indent: 2em;
/*首行缩进，数字＋单位(px|em);这个单位可以是px可以是em(一个文字的宽度),用的最多的还是em*/
		text-shadow: 2px 2px 2px red;
/*水平偏移距离 垂直偏移距离 模糊距离 阴影颜色;*/
		width: 1000px;
 		white-space:nowrap; /*空白符处理
 		normal默认值,文字超出容器宽度会自动换行,容器会变高
 		nowrap,文字超出容器宽度不会换行文本会在同一行上溢出。*/
  			
  		text-overflow: clip;
  		overflow: hidden;
  /*文本溢出处理方式 clip剪贴ellipsis显示省略号...*/
  		word-wrap: normal;
  /*长单词换行到下一行 break-word单词换行*/
	}
</style>

	选择器
	类选择器
	id选择器 交集,并集选择器
	相邻兄弟选择器 通用兄弟选择器

<head>
	<meta charset="utf-8">
 	<title>选择器</title>
 	<style type="text/css">
		.dang{/*类选择器*/color: blue;}
		#a1{/*id选择器，页面上所有的ID不能重复*/color: green;}
		/*类和id只能以下划线和英文字符开头，ID不是用来作为选择器添加样式的，它的主要作用是给JS使用*/
		body h2{/*后代选择器，body标签下所有h2标签都会被执行*/font-size: 50px;}
		body>p{/*子选择器，body标签下的前三个p标签被选择*/font-family: 楷体;}
		p.dang{/*交集选择器，p标签前两个被选中*/font-style: italic;}
		p,.dang/*并集选择器，所有p和.dang都会被选中*/
		p+h2/*相邻兄弟选择器，选中的是第一个h2*/
		p~h2/*通用兄弟选择器，选中的是p的向下兄弟所有的h2标签*/
                选择器可以是标签，ID，类
 	</style>
 </head>
 <body>
 		<p class="dang">你有糖吗</p>
 		<p class="dang">你有糖吗</p>
 		<p id="a1">你有糖吗</p>
 	<nav>
 		<p>你有糖吗</p>
 		<h2 class="dang">你有糖吗</h2>
 		<h2>你有糖吗</h2>
 	</nav>
 </body>

	序选择器

<head>
<meta charset="utf-8">
<title>13</title>
	<style type="text/css">
		p:first-child{    }
	/*找到同级别的第一个元素不区分类型7和12被选中*/
		p:last-child{   }
	/*找到同级别的最后一个元素不区分类型15被选中*/
		p:nth-child(n){color: red;}
	/*找到同级别的第n个元素不区分类型,n可以写为nx+y*/
		p:only-child{}
	/*不区分类型的同级别唯一元素*/
		p:first-of-type{color: red;}
	/*找到同级别的第一个元素区分类型2.7.12被选中*/
		p:last-of-type{  }
	/*找到同级别的最后一个元素区分类型6.10.15被选中*/
		p:nth-of-type(n){color: red;}
	</style>
</head>
<body>
	<h2>1</h2>
	<P>2</P>
	<P>3</P>
	<P>4</P>
	<P>5</P>
	<P>6</P>
	<div>
		<p>7</p>
		<p>8</p>
		<p>9</p>
		<p>10</p>
		<h2>11</h2>
		<ul>
			<li>
				<p>12</p>
				<p>13</p>
				<p>14</p>
				<p>15</p>
			</li>
		</ul>
	</div>
</body>

	属性选择器

<head>
<title></title>
<style type="text/css">
	[title]{color: green}
	[title="qwert"]{color: red;}
	[title|="qwert"]{}
/*属性的值以qwert开始,只能选中用“-”分隔的和独立的,是CSS2中的选择器*/
	[title^="qwert"]{}
/*所有以qwert属性值开始的都可以选中,
是CSS3中的选择器*/
	[title$="qwert"]{}
/*所有以属性值结尾的都可以选中,是CSS3中的选择器*/
	[title~="qwert"]{}
/*属性值包括什么，只能选中包括用空格分隔的和独立的,是CSS2中的选择器*/
	[title*="qwert"]{}
/*所有包括该属性值的都可以选中,是CSS3中的选择器*/
</style>
</head>
<body>
	<a href="#" title="">title</a>
	<a href="#" title="qwert">qwert</a>
	<a href="#" title="qwert yu">qwert yu</a>
	<a href="#" title="qwert_yu">qwert-yu</a>
	<a href="#" title="aaa.qwert">aaa.qwert</a>
	<a href="#" title="aaa.qwert.www">aaa.qwert.www</a>
	<a href="#" title="qwertyuiop">qwertyuiop</a>
	<p>我是谁</p>
</body>

	通用选择器 伪选择器

<head>
<title>1111</title>
<style type="text/css">
	*{color: red;}
/*通用选择器所有元素都被变红*/
	a:link{color: green}
/*默认状态*/
	a:visited{color: }
/*被访问过*/
	a:hover{color: }
/*鼠标悬停时*/
	a:active{color: }
/*鼠标点击时*/
/*四种状态可以同时都写，也可以单独写,如果全写的情况下必须遵循一定的顺序，特别是active要写到hover后面,否则就会被覆盖,因为点击的同时鼠标肯定是悬停在内容上的,hover对其他元素也起作用*/
	input:focus{outline-color: red;}
/*获取焦点边框颜色*/
	p:before{content: "你好"}
	p:after{content: "你好"}
/*在p标签的前后加上content*/
	</style>
</head>
<body>
	<h1>标题</h1>
	<p>段落</p>
	<a href="#">百度一下</a>
	<input type="text" name="text">
</body>

	盒子模型

1.
width: 300px;
height: 300px;
border: 50px solid pink;
border:宽度 样式 颜色
 颜色可以省略，默认的是黑色
 常见样式有dotted(点状),dashed(虚线),solid(实线)
 宽度可以省略，默认是1px
2.
border-width: 100px;
border-style: solid;
border-color: black;
 border-width:上 右 下 左;
 border-style:上 右 下 左;
 border-color:上 右 下 左;
按照顺时针方向设置，如果省略了一个边，就取对边的值，如果只设置了一个边，那么所有的边都一样
3.
border-top: 120px solid red;
border-right: 150px solid yellow;
border-bottom: 150px solid green;
border-left: 100px solid blue;
4.
 border-top-width: 宽度;
 border-top-style: 样式;
 border-top-color: 颜色;
 border-right-width: 宽度;
 border-right-style: 样式;
 border-right-color: 颜色;
 border-bottom-width: 宽度;
 border-bottom-style: 样式;
 border-bottom-color: 颜色;
 border-left-width: 宽度;
 border-left-style: 样式;
 border-left-color: 颜色;
内边距
padding:上 右 下 左;
按照顺时针方向设置。如果省略了一个边，就取对边的值，如果只设置了一个边，那么所有的边都一样
当设置内边距时会使盒子变大，可以设置box-sizing: border-box;使内容边距变小 盒子大小不变 
content-box为默认值 作用使盒子变大 内容区域不变
外边距
margin:上 右 下 左;
按照顺时针方向设置。如果省略了一个边，就取对边的值，如果只设置了一个边，那么所有的边都一样
水平方向上的margin值可以叠加
普通元素垂直方向上的margin值发生重叠现象，重叠后取较大的值
普通的父子元素，给子元素设置margin top时候，这个值会传递到父元素,可以通过给父元素添加边框或者是内边距来阻止margin值的传递,还可以给父元素添加overflow:hidden来阻止margin的值传递
外边距没有背景色
外边距不会影响元素的宽和高，但是会影响整个元素空间的宽和高
padding主要是用来设置父元素和子元素之间的距离，margin主要是用来设置元素和元素之间的距离
margin可以取负值,表示相反的方向
内容
元素的宽width和高height决定了真正可以填充内容的空间
取值可以是具体的像素也可以是百分比,百分比是相对于自己的父元素来说的
display: inline-block;使两个盒子水平排版
当两个盒子属于父子关系使，设置子盒子的width,height值时可以设置为百分比，相当父盒子的宽高

	盒子的圆角

 border-radius: 150px;/*或50%*/
 border-radius:取值1(左上 右上 右下 左下)/[取值2(左上 右上 右下 左下)]*/
 border-top-left-radius:取值1 [取值2];
 border-top-right-radius:取值1 [取值2];
 border-bottom-right-radius:取值1 [取值2];
 border-bottom-left-radius:取值1 [取值2];取值可以是px也可以是百分比
（width: 100px;
height: 100px;
border-right: 10px solid red;
border-top-right-radius: 60px;
border-bottom-right-radius: 60px;）月牙形状 通过只设置一个盒子的边来完成

	盒子行高和阴影

line-height: 40px;
使行高变为知道的数值利于计算内边距和其他数值*/
padding: 10px 10px;
利用内边距的设置及计算使文字在方框内垂直居中*/
box-shadow: 2px 2px 2px 2px black;
水平距离 垂直距离 模糊距离 阴影大小 阴影颜色 内外阴影默认outset，inset;
div:hover{
box-shadow: 2px 2px 2px 2px black;/*当鼠标悬浮到盒子时显示的阴影*/
cursor: pointer;当鼠标悬浮到盒子时的鼠标图标*/}

	盒子背景图片大小位置处理

background-image: url(../54/修罗.jpg);
background-color: green;
background-repeat: no-repeat;
repeat-x只在水平方向上平铺repeat-y只在垂直方向上平铺*/
background-attachment: fixed;
scroll(背景图片会随着滚动条的滚动而滚动)|fixed(背景图片固定在某个位置,不随滚动条的滚动而滚动)*/
background-position: center center;
background-position: 水平移动距离垂直移动距离
取值:具体的数值+px|方向单词
水平:right center left 垂直:top center bottom移动的参考点是容器的左上点
background: url(../54/修罗.jpg) green no-repeat fixed center center;连写
background-size:100% 100%;
background-size:宽度 高度 | 单词 
宽度和高度的取值有:
具体的像素
百分比(相对于容器)
auto auto(谁设置为auto把谁等比拉伸)
单词的取值有:
cover,图片等比拉伸到宽度和高度都填满元素，图片不变形，但可能会显示不全
contain,图片等比拉伸到宽度或高度中的一个填满元素另一个等比扩大或缩小，显示完全，不变形，但在整个盒子中可能会有空白区域
background-origin:padding-box;
格式padding-box(从内边距开始显示)border-box(从边框开始显示)content-box(从内容区域开始显示)
注意点:该属性用来指定从哪个区域开始显示背景图片,默认是padding-box
background-clip:padding-box;
格式padding-box(从内边距开始显示)border-box(从边框开始显示)content-box(从内容区域开始显示)
注意点:该属性用来指定从哪个区域开始显示背景颜色,默认是border-box*/

	块状 行内块状 行内元素

div{/*块状元素，
独占一行，
可设置宽高，
有默认宽高，
可设置边框，
可设置垂直和水平方向的内外边距
常见的块状元素 p div header nav section article footer h ul ol dl li dt dd ...*/
width: 200px;
height: 200px;
border: 1px solid red;}
span{/*行内元素
width height无效
垂直方向上的内外边距无效,但内边距可设置，外边距不可设置，其他跟块状元素效果一样
常见的行内元素span b u i s stong em ins del ...*/
	width: 200px;
	height: 200px;
	border: 1px solid red;
	margin: 20px 10px;
	padding: 20px 20px;}
p{width: 200px;
height: 200px;
border: 1px solid red;}
img{
/*行内块状，
除了不会独占一行，其他效果跟块状元素一样
常见的行内块级元素img input textarea ...*/
	width: 200px;
	height: 200px;
	border: 1px solid red;}
.aaa{display: inline-block;
/*给元素添加display可以手动的改变元素的显示模式,常见取值有:
	block 块级 
	inline 行内
	inline-block 行内块级*/
	vertical-align: top;
/*行内块状对齐方式vertical-align:baseline|top|middle|bottom|text-bottom，
	只有行内块状元素设置vertical-align属性才有效 
	默认的对齐方式是baseline(基线对齐)
	top是相对于父元素的顶部对齐
	middle是相对于父元素的中部对齐
	bottom是相对于是相对于父元素的底部对齐
	text-bottom是相对于父元素的文字底部对齐*/}

	浮动流布局

float: left/right；
没有中间对齐,对齐是相对于父元素的左右边框的
浮动流主要是用来水平排版的
虽然把元素设置为行内块状也可以实现水平排版,但有不足之处,例如左右水平排版,如果父元素宽度不固定的情况下会发生错位,所以在项目中一般都用浮动流来实现水平排版
由于脱离标准后,标准流中位置空闲了出来,因此后面标准流中的元素会去顶替脱离标准流的那个元素的位置 
浮动元素脱标后的在浮动流中的特点
因为脱离标准流,所以浮动的元素不区分块状，行内，行内块状，他的属性和行内块状一样
浮动流的元素不可以用margin: 0 auto;来水平居中
浮动元素脱标后在浮动流中的排列规则
同方向上,先浮动的显示在前面，后浮动的显示在后面,注意这个先后指的结构上的先后而不是css的书写先后
不同方向上,左浮动找左浮动元素，右浮动找右浮动元素
浮动后元素的位置由浮动前元素在标准流中的位置决定,这个位置主要指的是浮动前在标准流中是第几行,浮动后还是显示在第几行
由于浮动元素的位置和浮动前在标准流的位置有光,所以严格意识上说浮动元素是非完全脱标
	清除浮动
	方式一,
给前面的盒子添加高度
项目中一般高度是有内容撑起来的,尽量不设置高度
	方式二,
通过给第二个盒子添加clear属性来清除前面元素浮动带来的影响
clear: 	both;
clear属性的取值有:left|right|both|none(默认)
clear属性的意思是不让自己的子元素找前面浮动的元素
通过clear属性清除浮动会导致第一个盒子的margin-bottom和第二个盒子的margin-top失效,第二个盒子的margin-top失效是因为margin的值传递
	方式三
给第一个盒子和第二个盒子之间添加一个空盒子，并且给这个空盒子设置clear:both属性,俗称外墙法
第一个盒子的margin-bottom依然不可以用, 空盒子{clear: both;height: 20px;}
但是第二个盒子的margin-top可以用
可以通过设置空盒子的高度来达到设置margin-bottom/top的效果
	方法四,
给第一个盒子所有元素的后面添加一个空盒子，
<div class="wall">空盒子</div>
并且给这个空盒子设置clear:both属性,俗称内墙法
第一个盒子的margin-bottom可以用,第二个盒子的margin-top也可以用
也可以通过设置空盒子的高度来达到设置margin-bottom/top的效果
内墙法可以撑起盒子的高度，而外墙法不可以
	方法五,
通过伪元素选择器(:after)实现内墙法
.eee:after{content: "";
       	clear: both;
        display: block;
        height: 0px;
        visibility: hidden;}
 .eee{*zoom:1;} /*此代码适用于IE6*/
作用和内墙法一样，但是不用额外添加空元素，在第一个盒子的父元素盒子标签加 ：after 可以实现结构和样式分离，在实际项目开发中推荐使用*
	方式六,
通过给第一个盒子添加overflow: hidden来清除浮动

	定位流布局

1 相对定位
position：relative
top/right/bottom/left：10px;
四条边的移动距可以写一个,也可以写两个,写两个的时候要注意在同一个方向的只能设置一个边
相对定位元素是不脱离标准流的,所以相对定位元素在标准流当中的空间不会释放出来
相对定位元素是不脱离标准流的,所以相对定位元素区分块状，行内，行内块状
如果元素有margin/border/padding值,相对定位是在margin/border/padding值生效后起作用
相对定位元素主要用来对对元素进行微调和设置绝对定位的参考元素
2 绝对定位
position：absolute；
top/right/bottom/left：10px;
四条边的移动距可以写一个,也可以写两个,写两个的时候要注意在同一个方向的只能设置一个边
绝对定位元素是脱离标准流的,所以绝对定位元素在标准流中的空间会被释放出来
绝对定位元素是脱离标准流的,所以绝对定位元素不区分块状,行内,行内块状
3 绝对定位的参考点
绝对定位元素会参考离他最近的具有定位属性的祖先元素,
如果祖先中没有定位元素就参考body元素,
换句话说如果一个元素设置为绝对定位,首先去找他的父元素,
看他的父元素有没有position定位属性,如果没有就找他的父亲的父亲,直到找到第一个具有position属性的祖先,
然后相对于该祖先发生位置移动,如果所有祖先都没有position定位属性,就相对于body发生位置的移动
具有position定位属性指的是相对定位,绝对定位,固定定位,但不包括静态定位
父元素的margin/border的值对绝对定位的子元素的位置没有影响,绝对定位的子元素是从父元素的padding区域开始参考的,
但如果相对于body,始终相当于相对于浏览器的首屏的可视区域（相当整个浏览器的屏幕）
4 绝对定位的元素水平居中
left:50% 
margin-left:-x；
相对于贴靠元素的50% 然后-元素宽度的一半
5 固定定位
position：fixed；
top/right/bottom/left：10px;
固定定位元素是脱离标准流的,所以固定定位元素在标准流中的空间会被释放出来
固定定位元素是脱离标准流的,所以固定定位元素不区分块状,行内,行内块状
固定定位元素不会随着滚动条的移动而移动
固定定位元素始终参考的都是body 
6 静态定位
默认状态的定位
7 定位流中元素显示的顺序
默认情况下,定位流中的元素会盖住标准流中的元素默认情况下,定位流中后面的元素会覆盖住前面的元素
可以通过z-index：1；来更改元素的覆盖关系,值越大,显示越靠前,默认值是0
父级元素的z-index属性会影响到子元素的z-index,子元素的z-index属性最终的值是所有父级元素中最顶层（程序最外面最大的）父级元素的z-index值
父子关系的z-index属性之间不会相互覆盖（无效）。

	过度

transition-property: background-color,height;
transition-duration: 10s,8s;
transition-delay: 2s;
transition-timing-function: linear; 运行的方式
取值linear ease 默认的 ease-in ease-out ease-in-out cubic-bezier(x1,y1,x2,y2)*/
简写1 transition:width 3s linear 2s,background-color 3s linear 2s;属性 时间 速度 延迟时间
简写2 transition:width 3s,background-color 3s;
简写3 transition: all 3s

	模块的变化

旋转
transform: rotate(15deg)
transform: rotateX();/*沿x轴旋转*/
xy轴旋转配合加在父元素的透视perspective: xxpx;标签使用
transform: rotateY();/*沿y轴旋转*/
transform: rotateZ();/*默认是Z*/
旋转会改变坐标系
旋转写在平移前面是在旋转修改后的坐标系下平移
平移后旋转是在平移以后的位置默认中心点旋转*/
平移
transform: translate(100px,100px)
(水平方向移动距离,垂直方向移动距离)可为负数*/
缩放
transform: scale(1.5,1.5);
transform: scale(水平方向缩放比例,垂直方向缩放比例)
缩放比例如果是1代表不变,大于1代表放大,小于1代表缩小
如果水平和垂直方向上缩放比例一样,可以简写一个
复写
transform: translate(200px,200px) rotate(20deg) scale(1.5,1.5);
透明度 
opacity：0到1；
变化的基点
transform-origin: 50px 50px; 格式:水平方向移动距离 垂直方向移动距离;
变化基点就是以哪个点为参考点进行变化
变化基点的移动参考点是元素的左上角顶点
默认情况下所有的元素都是以自己的中心点作为参考来旋转的
移动距离可以是具体的像素,百分比,和关键字水平方向上有left center right,在垂直方向上有top center bottom

	动画

	animation-delay: 2s;
	animation-timing-function: ; /*linear|ease 默认的|ease-in|ease-out|ease-in-out|cubic-bezier(x1,y1,x2,y2);执行速度*/
	animation-iteration-count: ;/*具体的数字(默认是1)|infinite(无限循环);*/
	animation-direction: ;/* normal(默认状态不执行往返动画)|alternate(执行往返动画);*/
	animation-play-state: ;/*running(默认状态动画执行)|paused(鼠标悬浮时动画暂停)*/
	animation-fill-mode: ;/*none(不做改变)|backwards(动画等待时显示动画的第一帧)|
forwards(动画执行结束保持显示动画的最后一帧)|both(动画执行前显示动画的第一帧并且动画执行结束显示动画的最后一帧*/
	animation:bb 60s linear 2s infinite ;
/*动画的名称 动画的执行时间 动画的速度 延迟时间 动画的执行次数 是否执行往返动画;*/
	@keyframes bb{
		0%{margin-left: 0px;
		margin-top: 0px;
		background: red;}
		25%{margin-left: 400px;
		margin-top: 0px;
		background: yellow;}
		50%{margin-left: 400px;
		margin-top: 400px;
		background: green;}
		75%{margin-left: 0px;
		margin-top: 400px;
		background: blue;}
		100%{margin-left: 0px;
		margin-top: 0px;
		background: red;}
		}
	@keyframes bb{ 
		from{width: 500px;} 
		to{width: 1000px;}
		}

	3D转化

.father{
	width: 200px;
	height: 200px;
	background: yellow;
	transform-style: preserve-3d;
/*flat让子元素呈现2D展示；preserve-3d让子元素呈现3D展示*/
	}
.son{
	width: 100px;
	height: 100px;
	background: blue;
	}